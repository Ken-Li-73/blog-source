---
title: 背包问题：完全背包
abbrlink: 8b258efe
date: 2022-03-19 21:34:12
tags:
---

有`N`种物品和一个容量为`V`的背包，**每种物品都有无限件可用**。

<!--more-->

### 1.动态规划

```
f[i] 表示背包总容量是i的情况下，最大价值是多少
v[i] 表示第i个物品的容量是多少
w[i] 表示第i个物品的价值是多少
```
根据01背包的概念，完全背包其实就是在每种物品选择了0...V/vi个，转换为01背包问题，变成**第i种的第k个物品选不选择**的问题。

```
max{f[v1,v1,v1,...,v1,v2,v2,...,v2,v3,v3,...,v3,v4,...,...vm]}
```

```java
//状态表达式：在01背包的基础上进行扩展
for(int i=1;i<=n;i++){//选择第i种物品
    for(int j=m;j>v[i];j--){//在不选择第i中物品时，容量考虑选择到i-1种物品的最大价值
        for(int k = 0;k*v[i]<=j;k++){//在选择第i件物品时，选择几件，01背包的的扩展
            f[j] = Math.max(f[j],f[j-k*v[i]]+k*w[i]);
        }
    }
}    
```

### 2.优化：内层循环正序遍历

**意义：**
	表示在容量为0……V时，选择了第i件物品，由于是从小到大，**每个容量变化都包含着若干个体积为v[i]的物品**。
	因此正序，恰好可以满足包含选择若干个第i种物品的要求

```java
for(int i=1;i<=n;i++){//选择第i种物品
    for(int j=v[i];j<=m;j++){//在选择第i中物品时，容量更新前是i-1种物品的最大价值，更新后是考虑了第i种物品。
        f[j] = Math.max(f[j],f[j-v[i]]+w[i]);
    }
}    
```
**举例：**

​	在外循环第`i`层，内循环第`j`次时的更新`f[j]`，因此是正序，所以是从小到大遍历f数组。此时：

```
f[0]: 表示考虑第i个物品，容量为0时的价值。
f[1]: 表示考虑第i个物品，容量为1时的价值。
...
f[j-k*v[i]]:表示考虑第i个物品,容量为j-k*v[i]时的价值。
...
f[j-(k-1)*v[i]]:表示考虑第i个物品,容量为j-(k-1)*v[i]时的价值。
...
f[j-*v[i]]:表示考虑第i个物品,容量为j-v[i]时的价值。
...
f[j-1]: 表示考虑第i个物品，容量为j-1时的价值。
f[j]: 表示考虑第i-1个物品，容量为j时的价值。
f[j+1]: 表示考虑第i-1个物品，容量为j+1时的价值。
...
f[m]: 表示考虑第i-1个物品，容量为m时的价值。
```
迭代计算
```
计算f[j-(k-1)*v[i]] = Math.max(f[j-(k-1)*v[i]],f[j-k*v[i]]+w[i]),
计算f[j-(k-2)*v[i]] = Math.max(f[j-(k-2)*v[i]],f[j-(k-1)*v[i]]+w[i]),
...
计算f[j] = Math.max(f[j],f[j-v[i]]+w[i]),
```

发现：
	等式右侧用到的f[0...V]是考虑第i个物品后的最大价值
	计算f[j]之前已经计算了，f[j-k\*v[i]],f[j-(k-1)\*v[i]],...,f[j-v[i]],因此随着容量增大，前面的若干个第i种物品已经考虑到了

### 3.恰好装满的情况

完全背包是01背包的扩展，是可以变为01背包的，因此初始条件和[01背包问题]([背包问题：01背包 | 半日浮生 (mykebaby.com)](https://mykebaby.com/posts/d461a7e0/))是一样的
