---
title: 背包问题：多重背包
abbrlink: 7aaec587
date: 2022-03-20 19:07:07
tags:
---

有`N`种物品和一个容量为`V`的背包，**每种物品最多选s_i件可用**。

<!--more-->

### 1.概念

在完全背包的基础上对每种物品的数量加以限制，可以转换为01背包问题

```
f[i] 表示背包总容量是i的情况下，最大价值是多少
v[i] 表示第i个物品的容量是多少
w[i] 表示第i个物品的价值是多少
s[i] 表示第i个物品有多少个
```

```java
for(int i=1;i<=n;i++){
	for(int j=m;j>=v[i];j--){
		for(int k=1;k<=s[i]&&k*v[i]<=j;k++){  //每种选择k个
			f[j] = Math.max(f[j],f[j-k*v[i]]+k*w[i]);
		}
	}
}
```

### 2.优化

#### 2.1二进制优化

前提条件：0...n之间的数，可以用这几个数组合出来：1，2，4，2^k，n-2^k

如0~10可以用 1，2，4，3组合出来

将每种物品的数量二进制化

```java
/*
 *   class Goods{
 *       public int v;
 *       public int w;
 *       public Goods(int v, int w){
 *           this.v = v;
 *           this.w = w;
 *       }
 *    }
*/
int n = scan.nextInt();
int m = scan.nextInt();
ArrayList<Goods> list = new ArrayList<>();
for(int i = 1;i<=n;i++){
    int v = scan.nextInt();
    int w = scan.nextInt();
    int s = scan.nextInt();
    for(int k = 1;s-k>=0;k *= 2){
        s -= k;
        list.add(new Goods(k*v,k*w));
    }
    if(s>0) 
        list.add(new Goods(s*v,s*w));
}
```
转化为01背包问题
```java
for(Goods g: list){
    for(int j=m;j>=g.v;j--){
        f[j] = Math.max(f[j],f[j-g.v]+g.w);
    }
}
```

假设第i种物品有s个，则创建的物品有k+1个种类，分别是1个，2个，4个，...,2^k 个和s-2^k个物品的组合

#### 2.2二进制优化细节解释

对于1个第i种物品组合，内循环至f[j]时，数组内的状态

```
f[0] : 表示考虑第i-1个物品，容量为0时的价值。
f[1] : 表示考虑第i-1个物品，容量为0时的价值。
...
f[j-v[i]] : 表示考虑第i-1个物品，容量为j-v[i]时的价值。
...
f[j] : 表示考虑第i-1个物品，容量为j时的价值。
...
f[m] : 表示考虑第i个物品，容量为m时的价值。
此时f[j]考虑是否添加1个第i种物品
此时包含：0，1
```

对于2个第i种物品组合，内循环至f[j]时，数组内的状态

```
f[0] : 表示考虑第i-1个物品，容量为0时的价值。
f[1] : 表示考虑第i-1个物品，容量为0时的价值。
...
f[j-2*v[i]] : 表示考虑第i-1个物品，容量为j-2*v[i]时的价值。
...
f[j-v[i]] : 表示考虑第i个物品是否添加1个，容量为j-v[i]时的价值。
...
f[j] : 表示考虑第i个物品是否添加1个，容量为j时的价值。
...
f[m] : 表示考虑第i个物品是否添加2个，容量为m时的价值。

此时f[j]考虑在是否添加1个第i种物品的基础上，添加添加2个第i种物品的基础
此时包含：0+2，1+2
```

对于2^k个第i种物品组合，内循环至f[j]时，数组内的状态

```
f[0] : 表示考虑第i-1个物品，容量为0时的价值。
f[1] : 表示考虑第i-1个物品，容量为0时的价值。
...
f[j-2^k*v[i]] : 表示考虑第i-1个物品，容量为j-2^k*v[i]时的价值。
...
f[j-2^(k-1)*v[i]] : 表示考虑第i-1个物品是否添加2^(k-1)个，容量为j-2^(k-1)*v[i]时的价值。//第k-1次循环到里结束
...
f[j-2*v[i]] : 表示考虑第i个物品是否添加2^(k-1)个，容量为j-2*v[i]时的价值。
...
f[j-v[i]] : 表示考虑第i个物品是否添加2^(k-1)个，容量为j-v[i]时的价值。
...
f[j] : 表示考虑第i个物品是否添加是否添加2^(k-1)个，容量为j时的价值。
...
f[m] : 表示考虑第i个物品是否添加是否添加2^k个，容量为m时的价值。

此时f[j]考虑在是否添加1个第i种物品的基础上，添加添加2个第i种物品的基础
此时包含：0+2^k,1+2^k,2+2^k,1+2+2^k,....，1+2+4+...+2^k
```

因此可以全部包括数量的种类
