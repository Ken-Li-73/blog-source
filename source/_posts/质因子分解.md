---
title: 质因子分解
tags: 算法
abbrlink: 47c16ae7
date: 2022-03-11 11:47:50
---

找出一个数的所有质因子，并存储到数组中。

<!--more-->

### 1.知识点：

​    1.一个数n的乘因子一半的数量在该数的平方根√n以下

```
 证明：将一个数n分解因子，则可以有如下因子:(假设n/i都能被整除）
                1   n
                2   n/2
                3   n/3
                4   n/4
                ……  ……
                k   n/k
        从上向下观察，左侧因子是递增的，右侧是递减的，则最后的因子应该是相等的，即k=n/k,得出k=√n;
        因此只需要从1遍历到√n,找出能满足(n%i==0)条件的i,n/i,则可以找到所有乘因子。
```

​    2.另一半在平方根以上的乘因子，比√n大的质因子只有一个，其他均为合数。

       ```
       证明2：一个数n在平方根以上的乘因子，比√n大的质因子最多只有一个，其他因子均为合数。
       	反证法：假设存在两个及以上比√n大的质因子
       		则将数n按质因子的方式进行分解
       			n=a1*a2*a3*……*ak*ak+1*ak+2 
       		其中：
       			ai为大于1的质数，
       			ak为小于√n，且最接近√n的一个整数，
       			则ak+1，ak+2 ，为大于√n的质因子整数
       		计算ak+1*ak+2
       			∵ ak+1>√n, ak+2>√n
       			∴ ak+1*ak+2>√n*√n=n
       			则 a1*a2*a3*……*ak*ak+1*ak+2 >ak+1*ak+2> n
       	这与上面提出的等式冲突，说明不能存在两个及以上的比√n大的质因子
       ```

### 2. 程序实现

```java
//分解质因子
public List<Integer> numbers(int num){
    //1.建立存储空间，动态存储
    List<Integer> list = new ArrayList<>();
    int temp = num;
    //2.遍历到√n
    for(int i=2;i*i<=num;i++){
        //3.1如果能被整除，则添加进列表
        if(temp %i==0){
            list.add(i);
        }
        //3.2如果能被持续整除，则缩减被除数，去除相同的质因子（如果能一直被整除,则temp结果为1）
        while(temp %i==0){
            temp  /= i;
        }
    }
    //3.3最后添加可能出现的比√n大的质因子。
    if(temp>1) {
        list.add(temp);
    }
    return list;
}
```

3.转换数组

```java
//若要数组保存，可以使用java8中的stream
list.steam().mapToInt(i->i).toArray();
```

